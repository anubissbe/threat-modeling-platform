// import * as tf from '@tensorflow/tfjs-node'; // Temporarily disabled for testing
import { RandomForestClassifier } from 'ml-random-forest';
import { logger, mlLogger } from '../utils/logger';
import { 
  ModelType, 
  VulnerabilityPrediction, 
  PredictedVulnerability,
  RiskLevel,
  PredictionRequest,
  PredictionResponse,
  ComponentAnalysis 
} from '../types';
import { config } from '../config';

export class VulnerabilityPredictorService {
  private neuralNetwork: tf.LayersModel | null = null;
  private randomForest: RandomForestClassifier | null = null;
  private vulnerabilityPatterns: Map<string, VulnerabilityPattern> = new Map();
  private componentTypeFeatures: Map<string, number[]> = new Map();

  constructor() {
    this.initializePatterns();
    this.initializeComponentFeatures();
  }

  /**
   * Initialize vulnerability predictor models
   */
  async initialize(): Promise<void> {
    try {
      const startTime = Date.now();
      
      // Load neural network model
      const nnModelPath = `${config.MODEL_PATH}/vulnerability-nn`;
      try {
        this.neuralNetwork = await tf.loadLayersModel(`file://${nnModelPath}/model.json`);
      } catch (error) {
        logger.info('Creating new neural network model');
        this.neuralNetwork = this.createNeuralNetwork();
      }

      // Initialize random forest
      this.randomForest = new RandomForestClassifier({
        seed: 3,
        maxFeatures: 0.8,
        replacement: true,
        nEstimators: 100,
      });

      mlLogger.modelLoaded(ModelType.VULNERABILITY_PREDICTOR, '1.0.0', Date.now() - startTime);
      logger.info('Vulnerability predictor service initialized');
    } catch (error) {
      logger.error('Failed to initialize vulnerability predictor:', error);
      throw error;
    }
  }

  /**
   * Create neural network for vulnerability prediction
   */
  private createNeuralNetwork(): tf.Sequential {
    const model = tf.sequential({
      layers: [
        tf.layers.dense({
          inputShape: [50], // Feature vector size
          units: 128,
          activation: 'relu',
        }),
        tf.layers.batchNormalization(),
        tf.layers.dropout({ rate: 0.3 }),
        tf.layers.dense({
          units: 64,
          activation: 'relu',
        }),
        tf.layers.batchNormalization(),
        tf.layers.dropout({ rate: 0.3 }),
        tf.layers.dense({
          units: 32,
          activation: 'relu',
        }),
        tf.layers.dense({
          units: 15, // Number of vulnerability types
          activation: 'sigmoid', // Multi-label classification
        }),
      ],
    });

    model.compile({
      optimizer: tf.train.adam(0.001),
      loss: 'binaryCrossentropy',
      metrics: ['accuracy', 'precision', 'recall'],
    });

    return model;
  }

  /**
   * Initialize vulnerability patterns
   */
  private initializePatterns(): void {
    this.vulnerabilityPatterns.set('sql-injection', {
      indicators: ['sql', 'query', 'database', 'select', 'insert', 'update', 'delete'],
      riskFactors: ['user input', 'concatenation', 'dynamic query'],
      cweId: 'CWE-89',
      cvssBase: 7.5,
    });

    this.vulnerabilityPatterns.set('xss', {
      indicators: ['html', 'javascript', 'script', 'dom', 'innerHTML', 'document.write'],
      riskFactors: ['user input', 'no sanitization', 'dynamic content'],
      cweId: 'CWE-79',
      cvssBase: 6.1,
    });

    this.vulnerabilityPatterns.set('broken-auth', {
      indicators: ['login', 'password', 'session', 'token', 'auth', 'credential'],
      riskFactors: ['weak password', 'no mfa', 'session fixation'],
      cweId: 'CWE-287',
      cvssBase: 8.1,
    });

    this.vulnerabilityPatterns.set('sensitive-data', {
      indicators: ['pii', 'credit card', 'ssn', 'password', 'api key', 'secret'],
      riskFactors: ['no encryption', 'logging', 'transmission'],
      cweId: 'CWE-200',
      cvssBase: 7.5,
    });

    this.vulnerabilityPatterns.set('xxe', {
      indicators: ['xml', 'parser', 'external entity', 'dtd', 'doctype'],
      riskFactors: ['xml processing', 'external references'],
      cweId: 'CWE-611',
      cvssBase: 7.0,
    });

    this.vulnerabilityPatterns.set('insecure-deserialization', {
      indicators: ['serialize', 'deserialize', 'pickle', 'marshal', 'objectinputstream'],
      riskFactors: ['untrusted data', 'object creation'],
      cweId: 'CWE-502',
      cvssBase: 8.1,
    });

    this.vulnerabilityPatterns.set('security-misconfiguration', {
      indicators: ['config', 'default', 'admin', 'debug', 'verbose', 'error'],
      riskFactors: ['default settings', 'unnecessary features', 'verbose errors'],
      cweId: 'CWE-16',
      cvssBase: 5.3,
    });

    this.vulnerabilityPatterns.set('broken-access-control', {
      indicators: ['authorization', 'role', 'permission', 'access', 'privilege'],
      riskFactors: ['missing checks', 'privilege escalation', 'idor'],
      cweId: 'CWE-284',
      cvssBase: 8.0,
    });

    this.vulnerabilityPatterns.set('insufficient-logging', {
      indicators: ['log', 'audit', 'monitor', 'alert', 'event'],
      riskFactors: ['no logging', 'insufficient detail', 'no monitoring'],
      cweId: 'CWE-778',
      cvssBase: 4.0,
    });

    this.vulnerabilityPatterns.set('using-vulnerable-components', {
      indicators: ['dependency', 'library', 'package', 'version', 'outdated'],
      riskFactors: ['outdated versions', 'known vulnerabilities', 'no updates'],
      cweId: 'CWE-1104',
      cvssBase: 7.0,
    });
  }

  /**
   * Initialize component type features
   */
  private initializeComponentFeatures(): void {
    // Feature vectors for different component types
    this.componentTypeFeatures.set('web-application', [1, 0, 0, 0, 1, 1, 0, 1, 1, 0]);
    this.componentTypeFeatures.set('api', [0, 1, 0, 0, 1, 0, 1, 1, 0, 0]);
    this.componentTypeFeatures.set('database', [0, 0, 1, 0, 0, 0, 1, 0, 1, 1]);
    this.componentTypeFeatures.set('mobile-app', [1, 0, 0, 1, 1, 1, 0, 0, 1, 0]);
    this.componentTypeFeatures.set('microservice', [0, 1, 0, 0, 0, 0, 1, 1, 0, 1]);
    this.componentTypeFeatures.set('iot-device', [0, 0, 0, 1, 0, 1, 1, 0, 0, 1]);
    this.componentTypeFeatures.set('cloud-service', [0, 1, 1, 0, 1, 0, 1, 1, 1, 0]);
  }

  /**
   * Predict vulnerabilities for components
   */
  async predictVulnerabilities(request: PredictionRequest): Promise<PredictionResponse> {
    const startTime = Date.now();

    try {
      if (!this.neuralNetwork || !this.randomForest) {
        throw new Error('Models not initialized');
      }

      const components = this.extractComponents(request.input);
      const predictions: VulnerabilityPrediction[] = [];

      for (const component of components) {
        const features = this.extractFeatures(component);
        
        // Neural network prediction
        const nnPrediction = await this.predictWithNeuralNetwork(features);
        
        // Random forest prediction (if trained)
        let rfPrediction: number[] = [];
        try {
          rfPrediction = this.randomForest.predict([features])[0] as number[];
        } catch (error) {
          // Random forest might not be trained yet
          logger.debug('Random forest prediction skipped:', error);
        }

        // Combine predictions
        const vulnerabilities = this.combineAndProcessPredictions(
          nnPrediction,
          rfPrediction,
          component
        );

        predictions.push({
          componentId: component.id,
          vulnerabilities,
          overallRisk: this.calculateOverallRisk(vulnerabilities),
          recommendations: this.generateRecommendations(vulnerabilities),
        });

        // Log high-risk predictions
        vulnerabilities.forEach(vuln => {
          if (vuln.probability > 0.7) {
            mlLogger.vulnerabilityPredicted(component.id, vuln.type, vuln.probability);
          }
        });
      }

      const processingTime = Date.now() - startTime;
      const avgConfidence = this.calculateAverageConfidence(predictions);
      
      mlLogger.predictionMade(ModelType.VULNERABILITY_PREDICTOR, avgConfidence, processingTime);

      return {
        success: true,
        modelType: ModelType.VULNERABILITY_PREDICTOR,
        predictions: predictions.map(p => ({
          label: `Component ${p.componentId}`,
          confidence: this.calculateComponentConfidence(p),
          explanation: this.generateComponentExplanation(p),
          suggestedMitigations: p.recommendations.map(r => ({
            id: r,
            title: r,
            description: '',
            category: 'Security',
            effectiveness: 0.8,
            implementation: {
              steps: [],
              complexity: 'medium' as const,
            },
            references: [],
          })),
        })),
        metadata: {
          modelVersion: '1.0.0',
          processingTime,
          dataQuality: this.assessDataQuality(components),
          confidenceRange: [0.5, 0.95],
        },
        timestamp: new Date(),
      };

    } catch (error: any) {
      mlLogger.predictionError(ModelType.VULNERABILITY_PREDICTOR, error.message, request.input);
      throw error;
    }
  }

  /**
   * Extract components from input
   */
  private extractComponents(input: any): ComponentAnalysis[] {
    if (Array.isArray(input)) {
      return input;
    }
    
    if (input.components) {
      return input.components;
    }
    
    // Single component
    return [{
      id: input.id || 'component-1',
      type: input.type || 'unknown',
      description: input.description || '',
      dataFlow: input.dataFlow || [],
      technologies: input.technologies || [],
      interfaces: input.interfaces || [],
    }];
  }

  /**
   * Extract features from component
   */
  private extractFeatures(component: ComponentAnalysis): number[] {
    const features: number[] = [];

    // Component type features
    const typeFeatures = this.componentTypeFeatures.get(component.type) || new Array(10).fill(0);
    features.push(...typeFeatures);

    // Technology stack features
    const techFeatures = this.extractTechnologyFeatures(component.technologies || []);
    features.push(...techFeatures);

    // Interface features
    const interfaceFeatures = this.extractInterfaceFeatures(component.interfaces || []);
    features.push(...interfaceFeatures);

    // Data flow features
    const dataFlowFeatures = this.extractDataFlowFeatures(component.dataFlow || []);
    features.push(...dataFlowFeatures);

    // Text-based features from description
    const textFeatures = this.extractTextFeatures(component.description);
    features.push(...textFeatures);

    // Pad or truncate to expected size
    while (features.length < 50) features.push(0);
    return features.slice(0, 50);
  }

  /**
   * Extract technology features
   */
  private extractTechnologyFeatures(technologies: string[]): number[] {
    const features = new Array(10).fill(0);
    const techMap: Record<string, number> = {
      'javascript': 0, 'typescript': 0, 'python': 1, 'java': 2,
      'php': 3, 'ruby': 4, 'go': 5, 'rust': 6, 'c++': 7, 'c#': 8,
    };

    technologies.forEach(tech => {
      const index = techMap[tech.toLowerCase()];
      if (index !== undefined) {
        features[index] = 1;
      }
    });

    return features;
  }

  /**
   * Extract interface features
   */
  private extractInterfaceFeatures(interfaces: string[]): number[] {
    const features = new Array(10).fill(0);
    const interfaceMap: Record<string, number> = {
      'rest': 0, 'graphql': 1, 'grpc': 2, 'soap': 3, 'websocket': 4,
      'http': 5, 'https': 6, 'tcp': 7, 'udp': 8, 'mqtt': 9,
    };

    interfaces.forEach(iface => {
      const index = interfaceMap[iface.toLowerCase()];
      if (index !== undefined) {
        features[index] = 1;
      }
    });

    return features;
  }

  /**
   * Extract data flow features
   */
  private extractDataFlowFeatures(dataFlows: string[]): number[] {
    const features = new Array(10).fill(0);
    const patterns = [
      'user input', 'database', 'external api', 'file system',
      'cache', 'message queue', 'cloud storage', 'third party',
      'encryption', 'authentication'
    ];

    dataFlows.forEach(flow => {
      patterns.forEach((pattern, index) => {
        if (flow.toLowerCase().includes(pattern)) {
          features[index] = 1;
        }
      });
    });

    return features;
  }

  /**
   * Extract text features
   */
  private extractTextFeatures(description: string): number[] {
    const features = new Array(10).fill(0);
    const keywords = [
      'input', 'output', 'validation', 'authentication', 'authorization',
      'encryption', 'session', 'token', 'api', 'database'
    ];

    const lowerDesc = description.toLowerCase();
    keywords.forEach((keyword, index) => {
      if (lowerDesc.includes(keyword)) {
        features[index] = 1;
      }
    });

    return features;
  }

  /**
   * Predict with neural network
   */
  private async predictWithNeuralNetwork(features: number[]): Promise<number[]> {
    const inputTensor = tf.tensor2d([features]);
    const predictions = await this.neuralNetwork!.predict(inputTensor) as tf.Tensor;
    const result = await predictions.array() as number[][];
    
    inputTensor.dispose();
    predictions.dispose();
    
    return result[0] || [];
  }

  /**
   * Combine predictions from multiple models
   */
  private combineAndProcessPredictions(
    nnPredictions: number[],
    rfPredictions: number[],
    component: ComponentAnalysis
  ): PredictedVulnerability[] {
    const vulnerabilities: PredictedVulnerability[] = [];
    const vulnTypes = Array.from(this.vulnerabilityPatterns.keys());

    vulnTypes.forEach((vulnType, index) => {
      // Combine predictions (weighted average if both available)
      let probability = nnPredictions[index] || 0;
      if (rfPredictions.length > index) {
        probability = (probability * 0.7 + rfPredictions[index] * 0.3);
      }

      // Apply pattern matching boost
      const patternScore = this.calculatePatternScore(vulnType, component);
      probability = Math.min(probability + patternScore * 0.2, 1.0);

      if (probability >= config.CONFIDENCE_THRESHOLD - 0.2) {
        const pattern = this.vulnerabilityPatterns.get(vulnType)!;
        vulnerabilities.push({
          type: vulnType,
          probability,
          impact: this.determineImpact(pattern.cvssBase),
          exploitability: this.calculateExploitability(vulnType, component),
          description: this.generateVulnerabilityDescription(vulnType, component),
          cwe: pattern.cweId,
          cvss: pattern.cvssBase,
        });
      }
    });

    return vulnerabilities.sort((a, b) => b.probability - a.probability);
  }

  /**
   * Calculate pattern matching score
   */
  private calculatePatternScore(vulnType: string, component: ComponentAnalysis): number {
    const pattern = this.vulnerabilityPatterns.get(vulnType);
    if (!pattern) return 0;

    let score = 0;
    const text = (component.description + ' ' + component.technologies?.join(' ') + ' ' + 
                 component.interfaces?.join(' ')).toLowerCase();

    // Check indicators
    pattern.indicators.forEach(indicator => {
      if (text.includes(indicator)) {
        score += 0.1;
      }
    });

    // Check risk factors
    pattern.riskFactors.forEach(factor => {
      if (text.includes(factor)) {
        score += 0.15;
      }
    });

    return Math.min(score, 1.0);
  }

  /**
   * Determine impact level
   */
  private determineImpact(cvssScore: number): 'critical' | 'high' | 'medium' | 'low' {
    if (cvssScore >= 9.0) return 'critical';
    if (cvssScore >= 7.0) return 'high';
    if (cvssScore >= 4.0) return 'medium';
    return 'low';
  }

  /**
   * Calculate exploitability
   */
  private calculateExploitability(vulnType: string, component: ComponentAnalysis): number {
    const baseExploitability: Record<string, number> = {
      'sql-injection': 0.9,
      'xss': 0.85,
      'broken-auth': 0.8,
      'sensitive-data': 0.7,
      'xxe': 0.6,
      'insecure-deserialization': 0.75,
      'security-misconfiguration': 0.8,
      'broken-access-control': 0.85,
      'insufficient-logging': 0.5,
      'using-vulnerable-components': 0.9,
    };

    let exploitability = baseExploitability[vulnType] || 0.5;

    // Adjust based on component exposure
    if (component.interfaces?.includes('public') || component.type === 'web-application') {
      exploitability += 0.1;
    }

    return Math.min(exploitability, 1.0);
  }

  /**
   * Generate vulnerability description
   */
  private generateVulnerabilityDescription(vulnType: string, component: ComponentAnalysis): string {
    const descriptions: Record<string, string> = {
      'sql-injection': `SQL injection vulnerability detected in ${component.type}. User inputs may not be properly sanitized before database queries.`,
      'xss': `Cross-site scripting vulnerability found. User-supplied data might be rendered without proper encoding.`,
      'broken-auth': `Authentication weakness identified. The authentication mechanism may be vulnerable to bypass or session attacks.`,
      'sensitive-data': `Sensitive data exposure risk detected. Personal or confidential information might be transmitted or stored insecurely.`,
      'xxe': `XML External Entity vulnerability possible. XML parsing might allow external entity references.`,
      'insecure-deserialization': `Insecure deserialization detected. Untrusted data deserialization could lead to remote code execution.`,
      'security-misconfiguration': `Security misconfiguration found. Default or insecure settings may expose the component to attacks.`,
      'broken-access-control': `Access control vulnerability detected. Authorization checks might be missing or bypassable.`,
      'insufficient-logging': `Insufficient logging and monitoring. Security events might not be properly tracked or alerted.`,
      'using-vulnerable-components': `Vulnerable dependencies detected. Third-party components may contain known security vulnerabilities.`,
    };

    return descriptions[vulnType] || `Security vulnerability detected in ${component.type} component.`;
  }

  /**
   * Calculate overall risk level
   */
  private calculateOverallRisk(vulnerabilities: PredictedVulnerability[]): RiskLevel {
    if (vulnerabilities.length === 0) return RiskLevel.MINIMAL;

    const criticalCount = vulnerabilities.filter(v => v.impact === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.impact === 'high').length;
    const totalRisk = vulnerabilities.reduce((sum, v) => sum + v.probability * v.cvss!, 0);

    if (criticalCount > 0 || totalRisk > 15) return RiskLevel.CRITICAL;
    if (highCount > 2 || totalRisk > 10) return RiskLevel.HIGH;
    if (highCount > 0 || totalRisk > 5) return RiskLevel.MEDIUM;
    if (vulnerabilities.length > 0) return RiskLevel.LOW;
    
    return RiskLevel.MINIMAL;
  }

  /**
   * Generate recommendations
   */
  private generateRecommendations(vulnerabilities: PredictedVulnerability[]): string[] {
    const recommendations: string[] = [];

    vulnerabilities.forEach(vuln => {
      switch (vuln.type) {
        case 'sql-injection':
          recommendations.push('Use parameterized queries or prepared statements');
          recommendations.push('Implement input validation and sanitization');
          break;
        case 'xss':
          recommendations.push('Encode all user-supplied output');
          recommendations.push('Implement Content Security Policy (CSP)');
          break;
        case 'broken-auth':
          recommendations.push('Implement multi-factor authentication');
          recommendations.push('Use secure session management');
          break;
        case 'sensitive-data':
          recommendations.push('Encrypt sensitive data at rest and in transit');
          recommendations.push('Implement data classification and handling policies');
          break;
        case 'broken-access-control':
          recommendations.push('Implement proper authorization checks');
          recommendations.push('Use principle of least privilege');
          break;
        // Add more recommendations
      }
    });

    return [...new Set(recommendations)]; // Remove duplicates
  }

  /**
   * Calculate average confidence
   */
  private calculateAverageConfidence(predictions: VulnerabilityPrediction[]): number {
    const allProbabilities = predictions.flatMap(p => 
      p.vulnerabilities.map(v => v.probability)
    );
    
    if (allProbabilities.length === 0) return 0;
    
    return allProbabilities.reduce((sum, p) => sum + p, 0) / allProbabilities.length;
  }

  /**
   * Calculate component confidence
   */
  private calculateComponentConfidence(prediction: VulnerabilityPrediction): number {
    if (prediction.vulnerabilities.length === 0) return 0.95; // High confidence in no vulnerabilities
    
    return prediction.vulnerabilities[0]?.probability || 0;
  }

  /**
   * Generate component explanation
   */
  private generateComponentExplanation(prediction: VulnerabilityPrediction): string {
    const vulnCount = prediction.vulnerabilities.length;
    const risk = prediction.overallRisk;
    
    if (vulnCount === 0) {
      return `No significant vulnerabilities detected in component ${prediction.componentId}.`;
    }
    
    return `Found ${vulnCount} potential vulnerabilities with ${risk} overall risk in component ${prediction.componentId}.`;
  }

  /**
   * Assess data quality
   */
  private assessDataQuality(components: ComponentAnalysis[]): number {
    let totalQuality = 0;

    components.forEach(component => {
      const factors = {
        hasType: component.type !== 'unknown' ? 1 : 0,
        hasDescription: component.description.length > 20 ? 1 : 0.5,
        hasTechnologies: (component.technologies?.length || 0) > 0 ? 1 : 0,
        hasInterfaces: (component.interfaces?.length || 0) > 0 ? 1 : 0,
        hasDataFlow: (component.dataFlow?.length || 0) > 0 ? 1 : 0,
      };

      const quality = Object.values(factors).reduce((sum, val) => sum + val, 0) / 5;
      totalQuality += quality;
    });

    return totalQuality / components.length;
  }

  /**
   * Get model statistics
   */
  getModelStats(): any {
    return {
      type: ModelType.VULNERABILITY_PREDICTOR,
      neuralNetworkLoaded: this.neuralNetwork !== null,
      randomForestLoaded: this.randomForest !== null,
      patternsCount: this.vulnerabilityPatterns.size,
      componentTypes: this.componentTypeFeatures.size,
      version: '1.0.0',
    };
  }
}

interface VulnerabilityPattern {
  indicators: string[];
  riskFactors: string[];
  cweId: string;
  cvssBase: number;
}