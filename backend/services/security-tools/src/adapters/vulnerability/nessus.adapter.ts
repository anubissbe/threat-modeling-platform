import axios, { AxiosInstance } from 'axios';
import { BaseSecurityToolAdapter } from '../base.adapter';
import {
  VulnerabilityScannerIntegration,
  Vulnerability,
  SyncFilter,
  ScanPolicy,
  SeverityLevel
} from '../../types/security-tools';

export class NessusAdapter extends BaseSecurityToolAdapter {
  private client: AxiosInstance | null = null;
  private token: string | null = null;

  constructor(integration: VulnerabilityScannerIntegration) {
    super(integration);
  }

  async connect(): Promise<void> {
    try {
      const { endpoint, credentials, sslVerify = true } = this.connectionConfig;
      
      // Create axios instance
      this.client = axios.create({
        baseURL: endpoint,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        httpsAgent: sslVerify ? undefined : new (require('https').Agent)({ rejectUnauthorized: false }),
        timeout: (this.connectionConfig.timeout || 30) * 1000
      });

      // Authenticate
      const authResponse = await this.client.post('/session', {
        username: credentials.username,
        password: credentials.password
      });

      this.token = authResponse.headers['x-cookie'] || authResponse.data.token;
      this.client.defaults.headers.common['X-Cookie'] = `token=${this.token}`;
      
      this.isConnected = true;
      await this.emitEvent('integration.connected', { integrationId: this.integration.id });
    } catch (error) {
      this.isConnected = false;
      const toolError = this.handleError(error);
      await this.emitEvent('integration.error', toolError);
      throw toolError;
    }
  }

  async disconnect(): Promise<void> {
    try {
      if (this.client && this.token) {
        await this.client.delete('/session');
      }
      
      this.client = null;
      this.token = null;
      this.isConnected = false;
      
      await this.emitEvent('integration.disconnected', { integrationId: this.integration.id });
    } catch (error) {
      console.error('Error during Nessus disconnect:', error);
    }
  }

  async testConnection(): Promise<boolean> {
    try {
      if (!this.client || !this.token) {
        return false;
      }

      const response = await this.client.get('/server/status');
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }

  async sync(filter?: SyncFilter): Promise<void> {
    try {
      await this.emitEvent('sync.started', { integrationId: this.integration.id, filter });

      if (!this.isConnected) {
        await this.connect();
      }

      // Get scans
      const scans = await this.getScans(filter);
      
      // Process each scan
      for (const scan of scans) {
        const vulnerabilities = await this.getScanVulnerabilities(scan.id);
        
        for (const vuln of vulnerabilities) {
          await this.processVulnerability(vuln, scan);
        }
      }

      // Update last sync time
      this.integration.lastSync = new Date();
      
      await this.emitEvent('sync.completed', {
        integrationId: this.integration.id,
        scansProcessed: scans.length
      });
    } catch (error) {
      const toolError = this.handleError(error);
      await this.emitEvent('sync.failed', toolError);
      throw toolError;
    }
  }

  async createScan(policy: ScanPolicy): Promise<string> {
    if (!this.client) {
      throw new Error('Not connected to Nessus');
    }

    try {
      // Get policy UUID
      const policies = await this.client.get('/editor/policy/templates');
      const policyTemplate = policies.data.templates.find(
        (t: any) => t.name === policy.scanType || t.title === policy.scanType
      );

      if (!policyTemplate) {
        throw new Error(`Policy template ${policy.scanType} not found`);
      }

      // Create scan
      const scanData = {
        uuid: policyTemplate.uuid,
        settings: {
          name: policy.name,
          description: policy.description,
          text_targets: policy.targets.join(','),
          enabled: policy.schedule ? true : false
        }
      };

      if (policy.schedule) {
        scanData.settings = {
          ...scanData.settings,
          ...this.buildScheduleSettings(policy.schedule)
        };
      }

      const response = await this.client.post('/scans', scanData);
      return response.data.scan.id.toString();
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async launchScan(scanId: string): Promise<void> {
    if (!this.client) {
      throw new Error('Not connected to Nessus');
    }

    try {
      await this.client.post(`/scans/${scanId}/launch`);
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getScanStatus(scanId: string): Promise<string> {
    if (!this.client) {
      throw new Error('Not connected to Nessus');
    }

    try {
      const response = await this.client.get(`/scans/${scanId}`);
      return response.data.info.status;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  private async getScans(filter?: SyncFilter): Promise<any[]> {
    if (!this.client) {
      throw new Error('Not connected to Nessus');
    }

    try {
      const response = await this.client.get('/scans');
      let scans = response.data.scans || [];

      // Filter scans based on criteria
      if (filter && filter.timeRange) {
        scans = scans.filter((scan: any) => {
          const scanTime = new Date(scan.last_modification_date * 1000);
          return scanTime >= filter.timeRange!.start && scanTime <= filter.timeRange!.end;
        });
      }

      return scans;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  private async getScanVulnerabilities(scanId: string): Promise<any[]> {
    if (!this.client) {
      throw new Error('Not connected to Nessus');
    }

    try {
      const response = await this.client.get(`/scans/${scanId}`);
      const vulnerabilities = [];

      // Extract vulnerabilities from hosts
      for (const host of response.data.hosts || []) {
        const hostDetails = await this.client.get(`/scans/${scanId}/hosts/${host.host_id}`);
        
        for (const vuln of hostDetails.data.vulnerabilities || []) {
          vulnerabilities.push({
            ...vuln,
            host: host,
            scanId
          });
        }
      }

      return vulnerabilities;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  private async processVulnerability(nessusVuln: any, scan: any): Promise<void> {
    const vulnerability: Vulnerability = {
      id: `nessus-${nessusVuln.plugin_id}-${nessusVuln.host.hostname}`,
      scannerVulnId: nessusVuln.plugin_id.toString(),
      cve: this.extractCVE(nessusVuln) || '',
      cwe: this.extractCWE(nessusVuln) || '',
      title: nessusVuln.plugin_name,
      description: nessusVuln.synopsis || '',
      severity: this.mapNessusSeverity(nessusVuln.severity),
      cvssScore: nessusVuln.cvss_base_score,
      cvssVector: nessusVuln.cvss_vector,
      category: nessusVuln.plugin_family,
      family: nessusVuln.plugin_type,
      affectedAssets: [{
        assetId: nessusVuln.host.host_id.toString(),
        hostname: nessusVuln.host.hostname,
        ipAddress: nessusVuln.host.host_ip,
        port: nessusVuln.port,
        protocol: nessusVuln.protocol,
        service: nessusVuln.svc_name,
        operatingSystem: nessusVuln.host.operating_system,
        instanceId: `${nessusVuln.host.host_id}-${nessusVuln.plugin_id}`,
        output: nessusVuln.plugin_output,
        evidence: nessusVuln.plugin_output,
        status: 'vulnerable',
        lastChecked: new Date()
      }],
      exploitAvailable: nessusVuln.exploit_available || false,
      exploitMaturity: this.mapExploitMaturity(nessusVuln) || 'unproven',
      malwareKnown: nessusVuln.malware || false,
      inTheWild: nessusVuln.in_the_news || false,
      solution: nessusVuln.solution || 'No solution available',
      workaround: nessusVuln.workaround,
      patches: this.extractPatches(nessusVuln),
      firstSeen: new Date(scan.creation_date * 1000),
      lastSeen: new Date(scan.last_modification_date * 1000),
      scanId: scan.id.toString(),
      riskScore: this.calculateRiskScore(nessusVuln),
      businessImpact: this.assessBusinessImpact(nessusVuln),
      status: 'open'
    };

    // Apply field mappings
    const mappedVulnerability = this.applyFieldMappings(vulnerability);
    
    // Emit event for processing
    await this.emitEvent('vulnerability.discovered', {
      integrationId: this.integration.id,
      vulnerability: mappedVulnerability
    });
  }

  private extractCVE(vuln: any): string | undefined {
    if (vuln.cve) {
      return Array.isArray(vuln.cve) ? vuln.cve[0] : vuln.cve;
    }
    
    // Try to extract from description
    const cveMatch = (vuln.synopsis || vuln.description || '').match(/CVE-\d{4}-\d+/);
    return cveMatch ? cveMatch[0] : undefined;
  }

  private extractCWE(vuln: any): string | undefined {
    if (vuln.cwe) {
      return Array.isArray(vuln.cwe) ? vuln.cwe[0] : vuln.cwe;
    }
    
    // Try to extract from description
    const cweMatch = (vuln.synopsis || vuln.description || '').match(/CWE-\d+/);
    return cweMatch ? cweMatch[0] : undefined;
  }

  private mapNessusSeverity(severity: number): SeverityLevel {
    if (severity === 4) return 'critical';
    if (severity === 3) return 'high';
    if (severity === 2) return 'medium';
    if (severity === 1) return 'low';
    return 'info';
  }

  private mapExploitMaturity(vuln: any): 'functional' | 'poc' | 'unproven' | undefined {
    if (vuln.exploit_code_maturity === 'FUNCTIONAL') return 'functional';
    if (vuln.exploit_code_maturity === 'PROOF_OF_CONCEPT') return 'poc';
    if (vuln.exploit_code_maturity === 'UNPROVEN') return 'unproven';
    return undefined;
  }

  private extractPatches(vuln: any): any[] {
    const patches = [];
    
    if (vuln.patch_publication_date) {
      patches.push({
        id: `patch-${vuln.plugin_id}`,
        vendor: vuln.vendor || 'Unknown',
        product: vuln.product || 'Unknown',
        version: vuln.patch_version || 'Unknown',
        releaseDate: new Date(vuln.patch_publication_date * 1000),
        downloadUrl: vuln.patch_url
      });
    }
    
    return patches;
  }

  private calculateRiskScore(vuln: any): number {
    let score = 0;
    
    // Base score from CVSS
    if (vuln.cvss_base_score) {
      score += vuln.cvss_base_score * 10;
    }
    
    // Additional factors
    if (vuln.exploit_available) score += 20;
    if (vuln.malware) score += 15;
    if (vuln.in_the_news) score += 10;
    if (vuln.public_exploit) score += 15;
    
    return Math.min(100, score);
  }

  private assessBusinessImpact(vuln: any): string {
    const impacts = [];
    
    if (vuln.cvss_base_score >= 9) {
      impacts.push('Critical system compromise possible');
    }
    
    if (vuln.exploit_available) {
      impacts.push('Active exploitation risk');
    }
    
    if (vuln.malware) {
      impacts.push('Known malware targeting this vulnerability');
    }
    
    if (vuln.plugin_family === 'Web Servers') {
      impacts.push('Public-facing service at risk');
    }
    
    return impacts.join('. ') || 'Potential security impact';
  }

  private buildScheduleSettings(schedule: any): any {
    const settings: any = {
      launch: 'ON_DEMAND' // Default
    };

    if (schedule.frequency === 'daily') {
      settings.launch = 'DAILY';
      settings.starttime = schedule.time || '00:00';
    } else if (schedule.frequency === 'weekly') {
      settings.launch = 'WEEKLY';
      settings.starttime = schedule.time || '00:00';
      settings.rrules = `FREQ=WEEKLY;INTERVAL=1;BYDAY=${this.getDayAbbreviation(schedule.dayOfWeek || 0)}`;
    } else if (schedule.frequency === 'monthly') {
      settings.launch = 'MONTHLY';
      settings.starttime = schedule.time || '00:00';
      settings.rrules = `FREQ=MONTHLY;INTERVAL=1;BYMONTHDAY=${schedule.dayOfMonth || 1}`;
    }

    if (schedule.timezone) {
      settings.timezone = schedule.timezone;
    }

    return settings;
  }

  private getDayAbbreviation(dayNumber: number): string {
    const days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
    return days[dayNumber] || 'MO';
  }

  // Additional Nessus-specific methods
  async getPluginFamilies(): Promise<any[]> {
    if (!this.client) {
      throw new Error('Not connected to Nessus');
    }

    try {
      const response = await this.client.get('/plugins/families');
      return response.data.families || [];
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async exportScan(scanId: string, format: 'nessus' | 'pdf' | 'html' | 'csv' = 'pdf'): Promise<string> {
    if (!this.client) {
      throw new Error('Not connected to Nessus');
    }

    try {
      // Request export
      const exportResponse = await this.client.post(`/scans/${scanId}/export`, {
        format,
        chapters: 'vuln_hosts_summary;vuln_by_host;compliance_exec;remediations;vuln_by_plugin;compliance'
      });

      const fileId = exportResponse.data.file;

      // Poll for completion
      let exportReady = false;
      while (!exportReady) {
        const statusResponse = await this.client.get(`/scans/${scanId}/export/${fileId}/status`);
        
        if (statusResponse.data.status === 'ready') {
          exportReady = true;
        } else {
          await this.sleep(1000);
        }
      }

      // Download export
      const downloadResponse = await this.client.get(`/scans/${scanId}/export/${fileId}/download`, {
        responseType: 'arraybuffer'
      });

      // Return base64 encoded data
      return Buffer.from(downloadResponse.data).toString('base64');
    } catch (error) {
      throw this.handleError(error);
    }
  }
}