import { z } from 'zod';

export const createVulnerabilitySchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(255, 'Title must be less than 255 characters'),
  description: z.string()
    .min(1, 'Description is required')
    .max(2000, 'Description must be less than 2000 characters'),
  severity: z.enum(['Critical', 'High', 'Medium', 'Low']),
  component: z.string()
    .min(1, 'Component is required')
    .max(255, 'Component must be less than 255 characters'),
  version: z.string()
    .max(50, 'Version must be less than 50 characters')
    .optional(),
  impact: z.string()
    .min(1, 'Impact is required')
    .max(2000, 'Impact must be less than 2000 characters'),
  remediation: z.string()
    .min(1, 'Remediation is required')
    .max(2000, 'Remediation must be less than 2000 characters'),
  projectId: z.string().uuid('Invalid project ID format'),
  threatModelId: z.string().uuid('Invalid threat model ID format').optional(),
  cve: z.string()
    .regex(/^CVE-\d{4}-\d{4,}$/, 'Invalid CVE format')
    .optional(),
  cwe: z.string()
    .regex(/^CWE-\d+$/, 'Invalid CWE format')
    .optional(),
  cvss_score: z.number()
    .min(0, 'CVSS score must be between 0 and 10')
    .max(10, 'CVSS score must be between 0 and 10')
    .optional(),
  exploitability: z.enum(['Functional', 'Proof of Concept', 'Unproven', 'Not Defined']).optional(),
  remediationComplexity: z.enum(['Low', 'Medium', 'High']).optional(),
  businessImpact: z.enum(['Critical', 'High', 'Medium', 'Low']).optional(),
  references: z.array(z.string().url('Invalid URL format')).optional(),
  assignedTo: z.string()
    .max(255, 'Assigned to must be less than 255 characters')
    .optional(),
  affectedAssets: z.array(z.string().max(255, 'Asset name must be less than 255 characters')).optional(),
  tags: z.array(z.string().max(50, 'Tag must be less than 50 characters')).optional(),
  notes: z.string()
    .max(2000, 'Notes must be less than 2000 characters')
    .optional()
});

export const updateVulnerabilitySchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(255, 'Title must be less than 255 characters')
    .optional(),
  description: z.string()
    .min(1, 'Description is required')
    .max(2000, 'Description must be less than 2000 characters')
    .optional(),
  severity: z.enum(['Critical', 'High', 'Medium', 'Low']).optional(),
  status: z.enum(['open', 'in_progress', 'resolved', 'false_positive', 'wont_fix']).optional(),
  priority: z.enum(['P1', 'P2', 'P3', 'P4']).optional(),
  component: z.string()
    .min(1, 'Component is required')
    .max(255, 'Component must be less than 255 characters')
    .optional(),
  version: z.string()
    .max(50, 'Version must be less than 50 characters')
    .optional(),
  impact: z.string()
    .min(1, 'Impact is required')
    .max(2000, 'Impact must be less than 2000 characters')
    .optional(),
  remediation: z.string()
    .min(1, 'Remediation is required')
    .max(2000, 'Remediation must be less than 2000 characters')
    .optional(),
  cve: z.string()
    .regex(/^CVE-\d{4}-\d{4,}$/, 'Invalid CVE format')
    .optional(),
  cwe: z.string()
    .regex(/^CWE-\d+$/, 'Invalid CWE format')
    .optional(),
  cvss_score: z.number()
    .min(0, 'CVSS score must be between 0 and 10')
    .max(10, 'CVSS score must be between 0 and 10')
    .optional(),
  exploitability: z.enum(['Functional', 'Proof of Concept', 'Unproven', 'Not Defined']).optional(),
  remediationComplexity: z.enum(['Low', 'Medium', 'High']).optional(),
  businessImpact: z.enum(['Critical', 'High', 'Medium', 'Low']).optional(),
  references: z.array(z.string().url('Invalid URL format')).optional(),
  assignedTo: z.string()
    .max(255, 'Assigned to must be less than 255 characters')
    .optional(),
  affectedAssets: z.array(z.string().max(255, 'Asset name must be less than 255 characters')).optional(),
  tags: z.array(z.string().max(50, 'Tag must be less than 50 characters')).optional(),
  notes: z.string()
    .max(2000, 'Notes must be less than 2000 characters')
    .optional()
});

export function validateRequest<T>(schema: z.ZodSchema<T>) {
  return (req: any, res: any, next: any) => {
    try {
      const validatedData = schema.parse(req.body);
      req.validatedData = validatedData;
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        const errorMessages = error.errors.map(err => 
          `${err.path.join('.')}: ${err.message}`
        );
        
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errorMessages,
        });
      }
      
      next(error);
    }
  };
}