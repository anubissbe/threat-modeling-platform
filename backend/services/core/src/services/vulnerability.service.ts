import { Pool } from 'pg';
import { pool } from '../config/database';
import { logger } from '../utils/logger';
import { 
  Vulnerability, 
  CreateVulnerabilityRequest, 
  UpdateVulnerabilityRequest, 
  VulnerabilityFilters,
  VulnerabilityStatistics 
} from '../types/vulnerability';
import { v4 as uuidv4 } from 'uuid';

export class VulnerabilityService {
  
  constructor(private db: Pool = pool) {}

  async createVulnerability(
    userId: string, 
    organizationId: string, 
    data: CreateVulnerabilityRequest
  ): Promise<Vulnerability> {
    const client = await this.db.connect();
    
    try {
      const vulnerabilityId = uuidv4();
      const now = new Date();
      
      // Calculate priority based on severity and exploitability
      const priority = this.calculatePriority(data.severity, data.exploitability);
      
      const query = `
        INSERT INTO vulnerabilities (
          id, title, description, severity, status, priority,
          cve, cwe, cvss_score, component, version,
          impact, exploitability, remediation_complexity, business_impact,
          remediation, ref_links, assigned_to, discovered_at, last_seen,
          project_id, threat_model_id, affected_assets, tags, notes,
          created_by, created_at, updated_at, organization_id
        ) VALUES (
          $1, $2, $3, $4, $5, $6,
          $7, $8, $9, $10, $11,
          $12, $13, $14, $15,
          $16, $17, $18, $19, $20,
          $21, $22, $23, $24, $25,
          $26, $27, $28, $29
        ) RETURNING *
      `;
      
      const values = [
        vulnerabilityId,
        data.title,
        data.description,
        data.severity,
        'open', // Default status
        priority,
        data.cve || null,
        data.cwe || null,
        data.cvss_score || null,
        data.component,
        data.version || null,
        data.impact,
        data.exploitability || 'Not Defined',
        data.remediationComplexity || 'Medium',
        data.businessImpact || 'Medium',
        data.remediation,
        JSON.stringify(data.references || []),
        data.assignedTo || null,
        now,
        now,
        data.projectId,
        data.threatModelId || null,
        JSON.stringify(data.affectedAssets || []),
        JSON.stringify(data.tags || []),
        data.notes || '',
        userId,
        now,
        now,
        organizationId
      ];
      
      const result = await client.query(query, values);
      
      logger.info(`Created vulnerability: ${vulnerabilityId}`, { userId, organizationId });
      
      return this.mapRowToVulnerability(result.rows[0]);
    } finally {
      client.release();
    }
  }

  async getVulnerabilities(
    userId: string, 
    organizationId: string, 
    filters: VulnerabilityFilters = {}
  ): Promise<{ vulnerabilities: Vulnerability[]; total: number }> {
    const client = await this.db.connect();
    
    try {
      let whereConditions = ['v.organization_id = $1'];
      let queryParams: any[] = [organizationId];
      let paramIndex = 2;
      
      // Add filters
      if (filters.severity) {
        whereConditions.push(`v.severity = $${paramIndex}`);
        queryParams.push(filters.severity);
        paramIndex++;
      }
      
      if (filters.status) {
        whereConditions.push(`v.status = $${paramIndex}`);
        queryParams.push(filters.status);
        paramIndex++;
      }
      
      if (filters.projectId) {
        whereConditions.push(`v.project_id = $${paramIndex}`);
        queryParams.push(filters.projectId);
        paramIndex++;
      }
      
      if (filters.assignedTo) {
        whereConditions.push(`v.assigned_to = $${paramIndex}`);
        queryParams.push(filters.assignedTo);
        paramIndex++;
      }
      
      if (filters.search) {
        whereConditions.push(`(
          v.title ILIKE $${paramIndex} OR 
          v.description ILIKE $${paramIndex} OR 
          v.component ILIKE $${paramIndex}
        )`);
        queryParams.push(`%${filters.search}%`);
        paramIndex++;
      }
      
      const whereClause = whereConditions.join(' AND ');
      
      // Get total count
      const countQuery = `
        SELECT COUNT(*) as total 
        FROM vulnerabilities v 
        WHERE ${whereClause}
      `;
      
      const countResult = await client.query(countQuery, queryParams);
      const total = parseInt(countResult.rows[0].total);
      
      // Get vulnerabilities with pagination
      const limit = filters.limit || 20;
      const offset = filters.offset || 0;
      
      const query = `
        SELECT v.*, p.name as project_name
        FROM vulnerabilities v
        LEFT JOIN projects p ON v.project_id = p.id
        WHERE ${whereClause}
        ORDER BY v.severity DESC, v.created_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;
      
      queryParams.push(limit, offset);
      
      const result = await client.query(query, queryParams);
      
      const vulnerabilities = result.rows.map(row => this.mapRowToVulnerability(row));
      
      return { vulnerabilities, total };
    } finally {
      client.release();
    }
  }

  async getVulnerabilityById(
    vulnerabilityId: string, 
    userId: string, 
    organizationId: string
  ): Promise<Vulnerability> {
    const client = await this.db.connect();
    
    try {
      const query = `
        SELECT v.*, p.name as project_name
        FROM vulnerabilities v
        LEFT JOIN projects p ON v.project_id = p.id
        WHERE v.id = $1 AND v.organization_id = $2
      `;
      
      const result = await client.query(query, [vulnerabilityId, organizationId]);
      
      if (result.rows.length === 0) {
        throw new Error('Vulnerability not found or access denied');
      }
      
      return this.mapRowToVulnerability(result.rows[0]);
    } finally {
      client.release();
    }
  }

  async updateVulnerability(
    vulnerabilityId: string, 
    userId: string, 
    organizationId: string, 
    data: UpdateVulnerabilityRequest
  ): Promise<Vulnerability> {
    const client = await this.db.connect();
    
    try {
      // First check if vulnerability exists and user has access
      await this.getVulnerabilityById(vulnerabilityId, userId, organizationId);
      
      const updates: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;
      
      // Build dynamic update query
      Object.entries(data).forEach(([key, value]) => {
        if (value !== undefined) {
          if (key === 'references' || key === 'affectedAssets' || key === 'tags') {
            const columnName = key === 'references' ? 'ref_links' : this.camelToSnake(key);
            updates.push(`${columnName} = $${paramIndex}`);
            values.push(JSON.stringify(value));
          } else {
            updates.push(`${this.camelToSnake(key)} = $${paramIndex}`);
            values.push(value);
          }
          paramIndex++;
        }
      });
      
      if (updates.length === 0) {
        throw new Error('No fields to update');
      }
      
      // Add updated_at
      updates.push(`updated_at = $${paramIndex}`);
      values.push(new Date());
      paramIndex++;
      
      // Add resolved_at if status is being changed to resolved
      if (data.status === 'resolved') {
        updates.push(`resolved_at = $${paramIndex}`);
        values.push(new Date());
        paramIndex++;
      }
      
      values.push(vulnerabilityId, organizationId);
      
      const query = `
        UPDATE vulnerabilities 
        SET ${updates.join(', ')}
        WHERE id = $${paramIndex - 1} AND organization_id = $${paramIndex}
        RETURNING *
      `;
      
      const result = await client.query(query, values);
      
      logger.info(`Updated vulnerability: ${vulnerabilityId}`, { userId, organizationId });
      
      return this.mapRowToVulnerability(result.rows[0]);
    } finally {
      client.release();
    }
  }

  async deleteVulnerability(
    vulnerabilityId: string, 
    userId: string, 
    organizationId: string
  ): Promise<void> {
    const client = await this.db.connect();
    
    try {
      // First check if vulnerability exists and user has access
      await this.getVulnerabilityById(vulnerabilityId, userId, organizationId);
      
      const query = `
        DELETE FROM vulnerabilities 
        WHERE id = $1 AND organization_id = $2
      `;
      
      await client.query(query, [vulnerabilityId, organizationId]);
      
      logger.info(`Deleted vulnerability: ${vulnerabilityId}`, { userId, organizationId });
    } finally {
      client.release();
    }
  }

  async getVulnerabilityStatistics(
    organizationId: string, 
    projectId?: string
  ): Promise<VulnerabilityStatistics> {
    const client = await this.db.connect();
    
    try {
      let whereClause = 'WHERE organization_id = $1';
      const params = [organizationId];
      
      if (projectId) {
        whereClause += ' AND project_id = $2';
        params.push(projectId);
      }
      
      // Get overall statistics
      const statsQuery = `
        SELECT 
          COUNT(*) as total,
          COUNT(CASE WHEN severity = 'Critical' THEN 1 END) as critical,
          COUNT(CASE WHEN severity = 'High' THEN 1 END) as high,
          COUNT(CASE WHEN severity = 'Medium' THEN 1 END) as medium,
          COUNT(CASE WHEN severity = 'Low' THEN 1 END) as low,
          COUNT(CASE WHEN status = 'open' THEN 1 END) as open,
          COUNT(CASE WHEN status = 'in_progress' THEN 1 END) as in_progress,
          COUNT(CASE WHEN status = 'resolved' THEN 1 END) as resolved,
          COUNT(CASE WHEN status = 'false_positive' THEN 1 END) as false_positive,
          COUNT(CASE WHEN status = 'wont_fix' THEN 1 END) as wont_fix,
          COUNT(CASE WHEN created_at >= NOW() - INTERVAL '7 days' THEN 1 END) as new_this_week,
          COUNT(CASE WHEN status = 'resolved' AND resolved_at >= NOW() - INTERVAL '7 days' THEN 1 END) as resolved_this_week
        FROM vulnerabilities ${whereClause}
      `;
      
      const statsResult = await client.query(statsQuery, params);
      const stats = statsResult.rows[0];
      
      // Calculate average resolution time
      const avgResolutionQuery = `
        SELECT AVG(EXTRACT(EPOCH FROM (resolved_at - created_at))/86400) as avg_resolution_days
        FROM vulnerabilities 
        ${whereClause} AND status = 'resolved' AND resolved_at IS NOT NULL
      `;
      
      const avgResult = await client.query(avgResolutionQuery, params);
      const avgResolutionTime = parseFloat(avgResult.rows[0].avg_resolution_days) || 0;
      
      return {
        total: parseInt(stats.total),
        bySeverity: {
          critical: parseInt(stats.critical),
          high: parseInt(stats.high),
          medium: parseInt(stats.medium),
          low: parseInt(stats.low)
        },
        byStatus: {
          open: parseInt(stats.open),
          inProgress: parseInt(stats.in_progress),
          resolved: parseInt(stats.resolved),
          falsePositive: parseInt(stats.false_positive),
          wontFix: parseInt(stats.wont_fix)
        },
        trends: {
          newThisWeek: parseInt(stats.new_this_week),
          resolvedThisWeek: parseInt(stats.resolved_this_week),
          avgResolutionTime: Math.round(avgResolutionTime * 10) / 10
        }
      };
    } finally {
      client.release();
    }
  }

  private calculatePriority(
    severity: string, 
    exploitability?: string
  ): 'P1' | 'P2' | 'P3' | 'P4' {
    if (severity === 'Critical') return 'P1';
    if (severity === 'High') {
      return exploitability === 'Functional' ? 'P1' : 'P2';
    }
    if (severity === 'Medium') return 'P3';
    return 'P4';
  }

  private camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }

  private mapRowToVulnerability(row: any): Vulnerability {
    const safeJsonParse = (value: any, defaultValue: any = []) => {
      if (!value || value === null || value === undefined) return defaultValue;
      try {
        return JSON.parse(value);
      } catch (error) {
        return defaultValue;
      }
    };

    return {
      id: row.id,
      title: row.title,
      description: row.description,
      severity: row.severity,
      status: row.status,
      priority: row.priority,
      cve: row.cve,
      cwe: row.cwe,
      cvss_score: row.cvss_score,
      component: row.component,
      version: row.version,
      impact: row.impact,
      exploitability: row.exploitability,
      remediationComplexity: row.remediation_complexity,
      businessImpact: row.business_impact,
      remediation: row.remediation,
      references: safeJsonParse(row.ref_links, []),
      assignedTo: row.assigned_to,
      discoveredAt: row.discovered_at,
      lastSeen: row.last_seen,
      resolvedAt: row.resolved_at,
      projectId: row.project_id,
      threatModelId: row.threat_model_id,
      affectedAssets: safeJsonParse(row.affected_assets, []),
      tags: safeJsonParse(row.tags, []),
      notes: row.notes || '',
      createdBy: row.created_by,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      organizationId: row.organization_id
    };
  }
}